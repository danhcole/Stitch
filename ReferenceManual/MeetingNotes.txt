{\rtf1\ansi\ansicpg1252\cocoartf1348\cocoasubrtf170
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww12600\viewh7800\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\f0\fs24 \cf0 Things to bring up for tomorrow\'92s meeting:\
-Big question: Should we do positive or negative constraints, maybe a combination? How do we start to implement constraints in our language?\
-Can/should we handle I/O with multithreading? Reading is possible, but writing is not(?).\
-What other applications are there besides matrix manipulation that we can do with multithreading?\
\
Our next steps: \
-Take the pthread code and write same version in our language.\
-Come up with a \'93Hello world\'94 program for our language.\
\
\
Contents of the C Reference Manual\
\
Appendix A - Reference Manual 154 \

\b A.1 Introduction 154 \
A.2 Lexical Conventions 154 
\b0 \
A.2.1 Tokens 154 \
A.2.2 Comments 154\
A.2.3 Identifiers 154 \
A.2.4 Keywords 154 \
A.2.5 Constants 155 \
A.2.6 String Literals 156\
A.2.6 String Literals 156\

\b A.3 Syntax Notation 156 \
A.4 Meaning of Identifiers 157 
\b0 \
A.4.1 Storage Class 157 \
A.4.2 Basic Types 157 \
A.4.3 Derived types 158 \
A.4.4 Type Qualifiers 158 \

\b A.5 Objects and Lvalues 158 
\b0 \

\b A.6 Conversions 159 
\b0 \
A.6.1 Integral Promotion 159 \
A.6.2 Integral Conversions 159 \
A.6.3 Integer and Floating 159 \
A.6.4 Floating Types 159 \
A.6.5 Arithmetic Conversions 159 \
A.6.6 Pointers and Integers 160 \
A.6.7 Void 160 \
A.6.8 Pointers to Void 161 \

\b A.7 Expressions 161 
\b0 \
A.7.1 Pointer Conversion 161 \
A.7.2 Primary Expressions 161\
A.7.3 Postfix Expressions 162 \
A.7.4 Unary Operators 164 \
A.7.5 Casts 165 \
A.7.6 Multiplicative Operators 165 \
A.7.7 Additive Operators 166 \
A.7.8 Shift Operators 166 \
A.7.9 Relational Operators 167 \
A.7.10 Equality Operators 167 \
A.7.11 Bitwise AND Operator 167 \
A.7.12 Bitwise Exclusive OR Operator 167 \
A.7.13 Bitwise Inclusive OR Operator 168 \
A.7.14 Logical AND Operator 168 \
A.7.15 Logical OR Operator 168 \
A.7.16 Conditional Operator 168 \
A.7.17 Assignment Expressions 169 \
A.7.18 Comma Operator 169\
A.7.19 Constant Expressions 169 \

\b A.8 Declarations 170 
\b0 \
A.8.1 Storage Class Specifiers 170 \
A.8.2 Type Specifiers 171 \
A.8.3 Structure and Union Declarations 172 \
A.8.4 Enumerations 174 \
A.8.5 Declarators 175 \
A.8.6 Meaning of Declarators 176 \
A.8.7 Initialization 178 \
A.8.8 Type names 180 \
A.8.9 Typedef 181 \
A.8.10 Type Equivalence 181 \

\b A.9 Statements 181 
\b0 \
A.9.1 Labeled Statements 182\
A.9.2 Expression Statement 182 \
A.9.3 Compound Statement 182 \
A.9.4 Selection Statements 183 \
A.9.5 Iteration Statements 183 \
A.9.6 Jump statements 184\

\b A.10 External Declarations 184
\b0  \
A.10.1 Function Definitions 185 \
A.10.2 External Declarations 186\

\b A.11.Scope and Linkage 186 
\b0 \
A.11.1 Lexical Scope 187 \
A.11.2 Linkage 187\

\b A.12 Preprocessing 187 
\b0 \
A.12.1 Trigraph Sequences 188 \
A.12.2 Line Splicing 188 \
A.12.3 Macro Definition and Expansion 188 \
A.12.4 File Inclusion 190 \
A.12.5 Conditional Compilation 191 \
A.12.6 Line Control 192 \
A.12.7 Error Generation 192 \
A.12.8 Pragmas 192 \
A.12.9 Null directive 192 \
A.12.10 Predefined names 192\

\b A.13 Grammar}