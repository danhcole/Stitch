Things to bring up for tomorrow’s meeting:
-Big question: Should we do positive or negative constraints, maybe a combination? How do we start to implement constraints in our language?
-Can/should we handle I/O with multithreading? Reading is possible, but writing is not(?).
-What other applications are there besides matrix manipulation that we can do with multithreading?
-Start on the parser?  Where to start - basic math ops, etc. out of the way?

Our next steps: 
-Take the pthread code and write same version in our language.
-Come up with a “Hello world” program for our language.


Contents of the C Reference Manual

Appendix A - Reference Manual 154 
A.1 Introduction 154 
A.2 Lexical Conventions 154 
A.2.1 Tokens 154 
A.2.2 Comments 154
A.2.3 Identifiers 154 
A.2.4 Keywords 154 
A.2.5 Constants 155 
A.2.6 String Literals 156
A.2.6 String Literals 156
A.3 Syntax Notation 156 
A.4 Meaning of Identifiers 157 
A.4.1 Storage Class 157 
A.4.2 Basic Types 157 
A.4.3 Derived types 158 
A.4.4 Type Qualifiers 158 
A.5 Objects and Lvalues 158 
A.6 Conversions 159 
A.6.1 Integral Promotion 159 
A.6.2 Integral Conversions 159 
A.6.3 Integer and Floating 159 
A.6.4 Floating Types 159 
A.6.5 Arithmetic Conversions 159 
A.6.6 Pointers and Integers 160 
A.6.7 Void 160 
A.6.8 Pointers to Void 161 
A.7 Expressions 161 
A.7.1 Pointer Conversion 161 
A.7.2 Primary Expressions 161
A.7.3 Postfix Expressions 162 
A.7.4 Unary Operators 164 
A.7.5 Casts 165 
A.7.6 Multiplicative Operators 165 
A.7.7 Additive Operators 166 
A.7.8 Shift Operators 166 
A.7.9 Relational Operators 167 
A.7.10 Equality Operators 167 
A.7.11 Bitwise AND Operator 167 
A.7.12 Bitwise Exclusive OR Operator 167 
A.7.13 Bitwise Inclusive OR Operator 168 
A.7.14 Logical AND Operator 168 
A.7.15 Logical OR Operator 168 
A.7.16 Conditional Operator 168 
A.7.17 Assignment Expressions 169 
A.7.18 Comma Operator 169
A.7.19 Constant Expressions 169 
A.8 Declarations 170 
A.8.1 Storage Class Specifiers 170 
A.8.2 Type Specifiers 171 
A.8.3 Structure and Union Declarations 172 
A.8.4 Enumerations 174 
A.8.5 Declarators 175 
A.8.6 Meaning of Declarators 176 
A.8.7 Initialization 178 
A.8.8 Type names 180 
A.8.9 Typedef 181 
A.8.10 Type Equivalence 181 
A.9 Statements 181 
A.9.1 Labeled Statements 182
A.9.2 Expression Statement 182 
A.9.3 Compound Statement 182 
A.9.4 Selection Statements 183 
A.9.5 Iteration Statements 183 
A.9.6 Jump statements 184
A.10 External Declarations 184 
A.10.1 Function Definitions 185 
A.10.2 External Declarations 186
A.11.Scope and Linkage 186 
A.11.1 Lexical Scope 187 
A.11.2 Linkage 187
A.12 Preprocessing 187 
A.12.1 Trigraph Sequences 188 
A.12.2 Line Splicing 188 
A.12.3 Macro Definition and Expansion 188 
A.12.4 File Inclusion 190 
A.12.5 Conditional Compilation 191 
A.12.6 Line Control 192 
A.12.7 Error Generation 192 
A.12.8 Pragmas 192 
A.12.9 Null directive 192 
A.12.10 Predefined names 192
A.13 Grammar
